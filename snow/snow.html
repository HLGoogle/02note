<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alpine Ski - é›ªå±±å¤§å†’é™©</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f0ff; font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif; }
        
        /* UI å±‚ - é›ªå±±é£æ ¼ */
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: #2c3e50; font-weight: 800; z-index: 10;
            font-size: 24px; letter-spacing: 1px; pointer-events: none;
            text-shadow: 2px 2px 0px #fff;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: #2980b9; font-size: 16px; font-weight: bold;
            pointer-events: none; opacity: 0.9; z-index: 10;
            text-shadow: 1px 1px 0px #fff;
        }

        /* æµ®åŠ¨æ–‡å­—åŠ¨ç”»å®¹å™¨ */
        #floating-text-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden; z-index: 15;
        }
        
        .floating-score {
            position: absolute;
            color: #f1c40f; /* é‡‘å¸è‰² */
            font-weight: bold;
            font-size: 28px;
            text-shadow: 2px 2px 0px #d35400, -1px -1px 0 #fff;
            animation: floatUp 1.0s ease-out forwards;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes floatUp {
            0% { opacity: 1; top: 40%; transform: translateX(-50%) scale(0.5); }
            50% { transform: translateX(-50%) scale(1.5); }
            100% { opacity: 0; top: 20%; transform: translateX(-50%) scale(1.0); }
        }

        /* è°ƒè¯•æ—¥å¿—çª—å£ */
        #debug-console {
            position: fixed;
            bottom: 10px; right: 10px; width: 300px; height: 120px;
            background: rgba(255, 255, 255, 0.8);
            color: #333; font-family: 'Consolas', monospace;
            font-size: 11px; padding: 10px; overflow-y: auto;
            z-index: 10001; border: 1px solid #ccc; pointer-events: auto;
            text-align: left; line-height: 1.4; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #debug-console::-webkit-scrollbar { width: 5px; }
        #debug-console::-webkit-scrollbar-thumb { background: #bbb; border-radius: 4px; }

        /* åŠ è½½ç•Œé¢ - é›ªç™½é£æ ¼ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #87CEEB 0%, #ffffff 100%);
            color: #2980b9;
            display: flex; justify-content: center; align-items: center;
            z-index: 1000; flex-direction: column;
            transition: opacity 0.8s ease-out;
        }
        .loader-bar {
            width: 200px; height: 6px; background: rgba(255,255,255,0.5);
            border-radius: 4px; overflow: hidden; margin-top: 15px; position: relative;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .loader-progress {
            position: absolute; left: 0; top: 0; height: 100%; width: 50%;
            background: #3498db; animation: slide 1.5s infinite ease-in-out;
            transition: width 0.3s, background 0.3s;
        }
        @keyframes slide {
            0% { left: -50%; width: 30%; }
            50% { left: 20%; width: 80%; }
            100% { left: 100%; width: 10%; }
        }
        #loader-text { font-size: 14px; letter-spacing: 2px; font-weight: bold; text-shadow: 1px 1px 0 #fff; }

        /* æ¸¸æˆç»“æŸå¼¹çª— - é›ªå±±ç‰ˆ */
        #game-over-modal {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); 
            color: #2c3e50; padding: 30px;
            text-align: center; border: none; border-radius: 16px;
            z-index: 20; width: 320px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            max-height: 80vh; overflow: hidden;
            display: flex; flex-direction: column;
        }
        
        #game-over-modal h1 { margin: 0 0 10px 0; color: #e74c3c; font-size: 32px; letter-spacing: 2px; text-transform: uppercase; }
        
        /* åå­—è¾“å…¥åŒºåŸŸ */
        #name-input-section {
            display: none; margin: 15px 0;
            animation: fadeIn 0.5s;
        }
        
        input#player-name {
            background: #f0f3f5; border: 2px solid #bdc3c7; color: #2c3e50;
            padding: 8px; font-size: 16px; width: 60%; text-align: center;
            border-radius: 4px; outline: none; transition: 0.3s;
        }
        input#player-name:focus { border-color: #3498db; background: #fff; }

        button#submit-score-btn {
            background: #3498db; color: #fff; border: none; padding: 8px 15px;
            font-size: 14px; border-radius: 4px; cursor: pointer; margin-left: 5px;
            font-weight: bold;
        }
        button#submit-score-btn:hover { background: #2980b9; }

        #rank-status-msg { font-size: 12px; color: #7f8c8d; margin-top: 5px; min-height: 18px; }

        /* æ’è¡Œæ¦œåˆ—è¡¨åŒºåŸŸ */
        #leaderboard-section {
            margin-top: 15px; border-top: 2px solid #ecf0f1;
            padding-top: 10px; flex-grow: 1; overflow: hidden;
            display: flex; flex-direction: column;
        }

        #leaderboard-title {
            font-size: 14px; color: #95a5a6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
        }

        #leaderboard-list {
            list-style: none; padding: 0; margin: 0;
            overflow-y: auto; max-height: 200px;
            font-size: 13px; text-align: left;
            border: 1px solid #ecf0f1; background: #fafafa;
            border-radius: 4px;
        }
        
        #leaderboard-list::-webkit-scrollbar { width: 4px; }
        #leaderboard-list::-webkit-scrollbar-thumb { background: #bdc3c7; border-radius: 2px; }

        #leaderboard-list li {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            display: flex; justify-content: space-between;
            color: #34495e;
        }
        #leaderboard-list li:nth-child(odd) { background: #fff; }
        #leaderboard-list li:nth-child(even) { background: #f9f9f9; }
        #leaderboard-list li.highlight { color: #e74c3c; font-weight: bold; background: #fdedec; }
        
        .rank-num { width: 25px; color: #bdc3c7; display: inline-block; font-weight: bold; }
        .rank-name { flex-grow: 1; padding-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .rank-score { color: #2980b9; font-weight: 600; }

        .btn-group { display: flex; flex-direction: column; gap: 12px; margin-top: 20px; }
        button.action-btn { 
            border: none; padding: 12px; font-size: 16px; cursor: pointer; 
            border-radius: 30px; color: #fff; transition: 0.2s; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        #restart-btn { background: linear-gradient(135deg, #3498db, #2980b9); }
        #restart-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(52, 152, 219, 0.3); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="loader">
        <div id="loader-text">å‡†å¤‡æ»‘é›ªè£…å¤‡...</div>
        <div class="loader-bar"><div class="loader-progress"></div></div>
    </div>

    <div id="ui">æ»‘è¡Œè·ç¦»: <span id="score">0</span> ç±³</div>
    <div id="guide">ğŸ–±ï¸/âŒ¨ï¸/ğŸ‘† å·¦å³æ§åˆ¶æ»‘é›ª</div>
    <div id="floating-text-container"></div>

    <div id="debug-console">
        <div>> ç³»ç»Ÿå¯åŠ¨...</div>
    </div>

    <div id="game-over-modal" style="display: none;">
        <h1>ç¿»è½¦äº†!</h1>
        <p>æœ¬æ¬¡æ»‘è¡Œ: <span id="final-score" style="color: #2980b9; font-weight: bold; font-size: 20px;">0</span> ç±³</p>
        
        <div id="name-input-section">
            <div style="color: #e67e22; font-size: 14px; margin-bottom: 5px; font-weight: bold;">â„ï¸ æ»‘é›ªé«˜æ‰‹ï¼æ¦œä¸Šæœ‰å â„ï¸</div>
            <div style="display: flex; justify-content: center;">
                <input type="text" id="player-name" placeholder="è¾“å…¥ä½ çš„åå­—" maxlength="10">
                <button id="submit-score-btn" onclick="submitScore()">ç™»è®°</button>
            </div>
        </div>

        <div id="rank-status-msg">æ­£åœ¨è¿æ¥æ»‘é›ªä¿±ä¹éƒ¨...</div>

        <div id="leaderboard-section">
            <div id="leaderboard-title">TOP 100 æ»‘é›ªå¥å°†</div>
            <ul id="leaderboard-list">
                <li style="text-align: center; color: #999; padding: 20px;">åŠ è½½ä¸­...</li>
            </ul>
        </div>

        <div class="btn-group">
            <button id="restart-btn" class="action-btn" onclick="location.reload()">å†æ»‘ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // ==========================================
        // ğŸ”§ é…ç½®åŒºåŸŸ
        // ==========================================
        
        // è¯·åœ¨æ­¤å¤„å¡«å…¥ä½ çš„ Cloudflare Worker åœ°å€
        const CLOUDFLARE_WORKER_URL = "https://02run.pages.dev"; 

        // ==========================================
        
        // æ—¥å¿—ç³»ç»Ÿ
        function sysLog(msg, type='info') {
            const consoleEl = document.getElementById('debug-console');
            if(!consoleEl) return;
            const time = new Date().toLocaleTimeString('en-US', {hour12: false, hour: "numeric", minute: "numeric", second: "numeric"});
            const div = document.createElement('div');
            if(type === 'error') { div.style.color = '#e74c3c'; div.innerHTML = `[${time}] âŒ ${msg}`; console.error(msg); } 
            else if (type === 'warn') { div.style.color = '#f39c12'; div.innerHTML = `[${time}] âš ï¸ ${msg}`; } 
            else if (type === 'success') { div.style.color = '#27ae60'; div.innerHTML = `[${time}] âœ… ${msg}`; }
            else { div.innerHTML = `[${time}] > ${msg}`; }
            consoleEl.appendChild(div);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ
        function showFloatingText(text) {
            const container = document.getElementById('floating-text-container');
            const el = document.createElement('div');
            el.className = 'floating-score';
            el.innerText = text;
            container.appendChild(el);
            setTimeout(() => { if(el.parentNode) el.parentNode.removeChild(el); }, 1500);
        }

        // --- æ’è¡Œæ¦œé€»è¾‘ (ä¿æŒä¸å˜) ---
        const MOCK_DATA_KEY = 'alpine_ski_mock_leaderboard';
        function getMockLeaderboard() {
            let data = localStorage.getItem(MOCK_DATA_KEY);
            if (!data) {
                const initial = [
                    { name: "SnowMan", score: 800 },
                    { name: "SkiKing", score: 650 },
                    { name: "Penguin", score: 400 },
                    { name: "PolarBear", score: 200 }
                ];
                localStorage.setItem(MOCK_DATA_KEY, JSON.stringify(initial));
                return initial;
            }
            return JSON.parse(data);
        }

        async function fetchLeaderboard() {
           const apiUrl = CLOUDFLARE_WORKER_URL || "";
            try {
                const response = await fetch(`${apiUrl}/rankings`);
                if (!response.ok) throw new Error("API Error");
                return await response.json();
            } catch (e) {
                sysLog(`Fetch Rank Failed: ${e.message}`, 'error');
                return getMockLeaderboard(); 
            }
        }

        async function sendScoreToDB(name, score) {
            const apiUrl = CLOUDFLARE_WORKER_URL || "";
            try {
                const response = await fetch(`${apiUrl}/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score })
                });

                let result;
                try { result = await response.json(); } catch (jsonError) {
                    sysLog(`Parse Error: ${jsonError.message}`, 'error');
                    return { success: false, message: `æœåŠ¡å™¨é”™è¯¯ (${response.status})` };
                }

                if (!response.ok) {
                    const errorMsg = result.message || result.error || "æäº¤è¢«æ‹’ç»";
                    sysLog(`æäº¤å¤±è´¥: ${errorMsg}`, 'warn');
                    return { success: false, message: errorMsg };
                }
                return { success: true };
            } catch (e) {
                sysLog(`Submit Failed: ${e.message}`, 'error');
                return { success: false, message: "ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥" };
            }
        }

        let currentFinalScore = 0;
        let cachedLeaderboard = [];

        async function onGameOverUI(score) {
            currentFinalScore = score;
            const modal = document.getElementById('game-over-modal');
            const scoreText = document.getElementById('final-score');
            const inputSection = document.getElementById('name-input-section');
            const msgEl = document.getElementById('rank-status-msg');
            const listEl = document.getElementById('leaderboard-list');

            scoreText.innerText = score;
            modal.style.display = 'flex';
            inputSection.style.display = 'none';
            msgEl.innerText = "æ­£åœ¨è·å–æ’åæ•°æ®...";
            listEl.innerHTML = '<li style="text-align:center; padding:20px; color:#999;">åŠ è½½ä¸­...</li>';

            cachedLeaderboard = await fetchLeaderboard();
            renderLeaderboard(cachedLeaderboard);

            const maxListSize = 100;
            const minScoreOnBoard = cachedLeaderboard.length < maxListSize ? 0 : cachedLeaderboard[cachedLeaderboard.length - 1].score;

            if (score > minScoreOnBoard || cachedLeaderboard.length < maxListSize) {
                inputSection.style.display = 'block';
                msgEl.innerText = "è¯·è¾“å…¥åå­—ä»¥ç™»è®°æˆç»©";
                msgEl.style.color = "#e67e22";
            } else {
                inputSection.style.display = 'none';
                msgEl.innerText = "è·ç¦»ä¸Šæ¦œè¿˜å·®ä¸€ç‚¹ç‚¹ï¼Œä¸‹æ¬¡åŠªåŠ›ï¼";
                msgEl.style.color = "#7f8c8d";
            }
        }

        function renderLeaderboard(data) {
            const listEl = document.getElementById('leaderboard-list');
            listEl.innerHTML = '';
            
            if (data.length === 0) {
                listEl.innerHTML = '<li style="text-align:center; padding:20px; color:#999;">æš‚æ— æ•°æ®ï¼Œå¿«æ¥æŠ¢ç¬¬ä¸€ï¼</li>';
                return;
            }

            data.forEach((item, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="rank-num">${index + 1}.</span>
                    <span class="rank-name">${escapeHtml(item.name)}</span>
                    <span class="rank-score">${item.score}m</span>
                `;
                listEl.appendChild(li);
            });
        }

        async function submitScore() {
            const input = document.getElementById('player-name');
            const btn = document.getElementById('submit-score-btn');
            const name = input.value.trim();
            
            if (!name) { alert("åå­—ä¸èƒ½ä¸ºç©º"); return; }

            btn.disabled = true;
            btn.innerText = "æäº¤ä¸­...";

            const res = await sendScoreToDB(name, currentFinalScore);
            
            if (res.success) {
                document.getElementById('name-input-section').style.display = 'none';
                document.getElementById('rank-status-msg').innerText = "ç™»è®°æˆåŠŸï¼";
                document.getElementById('rank-status-msg').style.color = "#27ae60";
                cachedLeaderboard = await fetchLeaderboard();
                renderLeaderboard(cachedLeaderboard);
            } else {
                btn.disabled = false;
                btn.innerText = "é‡è¯•";
                alert(res.message); 
            }
        }

        function escapeHtml(text) {
            if (!text) return "Unknown";
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }


        // CDN åˆ—è¡¨
        const CDN_LIST = [
            "https://lib.baomitu.com/three.js/r128/three.min.js",
            "https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js",
            "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
        ];

        let currentCdnIndex = 0;

        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = () => resolve();
                script.onerror = () => reject();
                document.head.appendChild(script);
            });
        }

        async function tryLoadEngine() {
            if (currentCdnIndex >= CDN_LIST.length) {
                document.getElementById('loader-text').innerText = "FATAL ERROR: NO NETWORK";
                return;
            }
            const url = CDN_LIST[currentCdnIndex];
            sysLog(`è¿æ¥å¼•æ“èŠ‚ç‚¹ ${currentCdnIndex + 1}...`);
            
            try {
                await Promise.race([
                    loadScript(url),
                    new Promise((_, r) => setTimeout(() => r(new Error("Timeout")), 3000))
                ]);
                sysLog("3Då¼•æ“åŠ è½½å®Œæˆï¼", 'success');
                document.getElementById('loader-text').innerText = "æ­£åœ¨æ„å»ºé›ªå±±åœºæ™¯...";
                setTimeout(initGame, 100);
            } catch (error) {
                currentCdnIndex++;
                tryLoadEngine(); 
            }
        }

        tryLoadEngine();

        // --- ğŸ¨ é›ªå±±é£æ ¼çº¹ç†ç”Ÿæˆå™¨ ---
        
        // ğŸŒ² æ¾æ ‘çº¹ç† (Green Pine)
        function createPineTreeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512; 
            const ctx = canvas.getContext('2d');
            
            // ç®€å•çš„ä¸‰è§’å½¢å †å 
            ctx.fillStyle = '#2d5a27'; // æ·±ç»¿è‰²
            ctx.beginPath();
            ctx.moveTo(256, 20);
            ctx.lineTo(450, 480);
            ctx.lineTo(62, 480);
            ctx.fill();
            
            // æ·»åŠ ä¸€äº›é›ªåœ¨æ ‘ä¸Š
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(256, 20);
            ctx.lineTo(320, 150);
            ctx.lineTo(192, 150);
            ctx.fill();
            
            // æ ‘å¹²
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(236, 480, 40, 32);

            return new THREE.CanvasTexture(canvas);
        }

        // ğŸª¨ å²©çŸ³/é›ªå †çº¹ç† (Rock/Snow Mound)
        function createRockTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // ç°è‰²å²©çŸ³åº•
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.arc(128, 128, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // é¡¶éƒ¨ç§¯é›ª
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath();
            ctx.arc(128, 110, 80, 0, Math.PI * 2);
            ctx.fill();

            // é˜´å½±ç»†èŠ‚
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(128, 128, 100, 0, Math.PI * 2);
            ctx.stroke();

            return new THREE.CanvasTexture(canvas);
        }

        // ğŸŸ¡ é‡‘å¸/æ°´æ™¶çº¹ç† (Coin/Crystal)
        function createCoinTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // é‡‘è‰²å¤–åœˆ
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(128, 128, 110, 0, Math.PI * 2);
            ctx.fill();
            
            // å†…éƒ¨é«˜äº®
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(128, 128, 90, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸­é—´æœ‰ä¸ªé›ªèŠ±ç¬¦å·æˆ–$
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â„', 128, 135);

            return new THREE.CanvasTexture(canvas);
        }

        // --- â›°ï¸ åœ°å½¢ç³»ç»Ÿ (å¹³æ»‘é›ªå¡) ---
        function getElevation(x, z) {
            // å‡å°‘é«˜åº¦å˜åŒ–ï¼Œè®©é›ªåœ°æ›´å¹³æ»‘ï¼Œé€‚åˆæ»‘é›ª
            const h1 = Math.sin(x * 0.03) * Math.cos(z * 0.02) * 2.0;
            const h2 = Math.cos(x * 0.08 + 1.0) * 0.8;
            return -3.0 + h1 + h2; 
        }

        // --- æ¸¸æˆä¸»é€»è¾‘ ---
        function initGame() {
            try {
                let baseSpeed = 0.5; let speed = baseSpeed;
                let score = 0; // åŸºç¡€è·ç¦»
                let bonusScore = 0; 
                let playerVelocityX = 0; let mouseXNormal = 0;
                let isGameOver = false; let time = 0; let finalScore = 0;
                let startTime = performance.now(); let lastLevel = 0;
                let distanceRun = 0;
                const playerHeight = 1.8; 

                // --- å¥–åŠ±ç”Ÿæˆæ§åˆ¶ ---
                let lastFlowerSpawnTime = performance.now();
                let flowerSpawnInterval = 2000; 

                sysLog("åˆå§‹åŒ–æ»‘é›ªåœº...");
                const scene = new THREE.Scene();
                // â„ï¸ æ›´æ”¹èƒŒæ™¯é¢œè‰²ä¸ºå¤©ç©ºè“/é›¾ç™½
                const skyColor = 0x87CEEB; // Sky Blue
                const fogColor = 0xe0f0ff; // Light snowy fog
                scene.background = new THREE.Color(skyColor);
                scene.fog = new THREE.Fog(fogColor, 15, 120); 

                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
                camera.position.set(0, playerHeight, 5);

                const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 800);

                // â˜€ï¸ é˜³å…‰ (Directional Light) ä»£æ›¿æ‰‹ç”µç­’
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                sunLight.position.set(50, 100, 50);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.camera.left = -100;
                sunLight.shadow.camera.right = 100;
                sunLight.shadow.camera.top = 100;
                sunLight.shadow.camera.bottom = -100;
                scene.add(sunLight);

                // ç¯å¢ƒå…‰å¢å¼ºï¼Œæ¨¡æ‹Ÿé›ªåœ°åå…‰
                const ambient = new THREE.AmbientLight(0xccccff, 0.6); 
                scene.add(ambient);

                // --- åœ°é¢ (é›ªåœ°) ---
                const groundMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, roughness: 0.8, metalness: 0.1 
                });
                const groundGeo = new THREE.PlaneGeometry(200, 200, 60, 60);
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2; 
                ground.receiveShadow = true; 
                scene.add(ground);

                sysLog("ç”Ÿæˆç´ æ...");
                const pineTexture = createPineTreeTexture();
                const rockTexture = createRockTexture();
                const coinTexture = createCoinTexture();

                // --- å®ä½“ç³»ç»Ÿ ---
                const treeCount = 400; const bushCount = 200; 
                const flowerPoolSize = 15; 
                const spawnDistance = 140; 
                
                // ğŸŒ² æ ‘æœ¨
                const treeGeo = new THREE.PlaneGeometry(2, 4); treeGeo.translate(0, 2, 0); 
                const treeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, map: pineTexture, alphaTest: 0.5, side: THREE.DoubleSide, transparent: true
                });
                treeMat.customDepthMaterial = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking, map: pineTexture, alphaTest: 0.5 });
                const treeMesh = new THREE.InstancedMesh(treeGeo, treeMat, treeCount);
                treeMesh.castShadow = true; treeMesh.receiveShadow = true;
                scene.add(treeMesh);

                // ğŸª¨ å²©çŸ³ (åŸçŒæœ¨)
                const bushGeo = new THREE.PlaneGeometry(2, 2); bushGeo.translate(0, 1, 0);
                const bushMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, map: rockTexture, alphaTest: 0.5, side: THREE.DoubleSide, transparent: true 
                });
                const bushMesh = new THREE.InstancedMesh(bushGeo, bushMat, bushCount);
                bushMesh.castShadow = true; bushMesh.receiveShadow = true;
                scene.add(bushMesh);

                // ğŸŸ¡ é‡‘å¸ (åŸèŠ±æœµ)
                const flowerGeo = new THREE.PlaneGeometry(1.5, 1.5); flowerGeo.translate(0, 0.75, 0);
                const flowerMat = new THREE.MeshBasicMaterial({
                    map: coinTexture, alphaTest: 0.5, side: THREE.DoubleSide, transparent: true 
                });
                const flowerMesh = new THREE.InstancedMesh(flowerGeo, flowerMat, flowerPoolSize);
                scene.add(flowerMesh);

                const treesData = []; const bushesData = []; const flowersData = [];
                const dummy = new THREE.Object3D(); 

                for (let i = 0; i < treeCount; i++) treesData.push(createEntityData('tree'));
                for (let i = 0; i < bushCount; i++) bushesData.push(createEntityData('bush'));
                for (let i = 0; i < flowerPoolSize; i++) flowersData.push(createEntityData('flower'));

                function createEntityData(type) {
                    const spread = 800; // ç¨å¾®çª„ä¸€ç‚¹çš„èµ›é“æ„Ÿ
                    const z = -Math.random() * spawnDistance;
                    let x = (Math.random() - 0.5) * spread;
                    
                    if (type === 'tree') {
                        // éšæœºå¤§å°çš„æ¾æ ‘
                        const scale = 1.0 + Math.random() * 2.0; 
                        return { x, z, scaleX: scale, scaleY: scale };
                    } else if (type === 'bush') {
                        const scale = 0.8 + Math.random() * 1.0;
                        return { x, z, scaleX: scale, scaleY: scale };
                    } else if (type === 'flower') {
                        return { x: 0, z: -999, active: false }; 
                    }
                }

                function spawnBonus() {
                    const flower = flowersData.find(f => !f.active);
                    if (flower) {
                        flower.active = true;
                        flower.z = camera.position.z - spawnDistance;
                        // å¥–åŠ±é€šå¸¸å‡ºç°åœ¨æ¯”è¾ƒå®¹æ˜“åƒåˆ°çš„åœ°æ–¹
                        flower.x = camera.position.x + (Math.random() - 0.5) * 20; 
                    }
                }

                // â„ï¸ ç²’å­ç³»ç»Ÿ - æ¼«å¤©é£é›ª (ä¿®æ­£ç‰ˆ)
                const particleCount = 1500; // å¢åŠ æ•°é‡
                const particleGeo = new THREE.BufferGeometry();
                const particlePos = new Float32Array(particleCount * 3);
                for(let i=0; i<particleCount*3; i+=3) {
                    // Xè½´ï¼šå¤§å¹…å¢åŠ å®½åº¦ï¼Œè¦†ç›–æ•´ä¸ªè§†é‡
                    particlePos[i] = (Math.random() - 0.5) * 150;   
                    // Yè½´ï¼šé«˜åº¦
                    particlePos[i+1] = Math.random() * 30; 
                    // Zè½´ï¼šæ·±åº¦è¦†ç›–
                    particlePos[i+2] = (Math.random() - 0.5) * 60 - 10;       
                }
                particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
                // é›ªèŠ±æ˜¯ç™½è‰²çš„
                const particleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 });
                const particleSystem = new THREE.Points(particleGeo, particleMat);
                scene.add(particleSystem); 

                function updateMeshMatrix(mesh, dataArray, index) {
                    const data = dataArray[index];
                    dummy.position.set(data.x, data.y, data.z);
                    
                    if (mesh === flowerMesh) {
                        // é‡‘å¸æ—‹è½¬ç‰¹æ•ˆ
                        dummy.rotation.set(0, time * 3 + index, 0);
                    } else {
                        // æ ‘æœ¨å’Œå²©çŸ³æ€»æ˜¯é¢å‘æ‘„åƒæœº (Billboard æ•ˆæœ) æˆ–è€…æ˜¯å›ºå®šçš„
                        // è¿™é‡Œçš„ PlaneGeometry éœ€è¦é¢å‘æ‘„åƒæœº
                        dummy.lookAt(camera.position.x, dummy.position.y, camera.position.z + 20); 
                    }
                    
                    if(mesh !== flowerMesh) dummy.scale.set(data.scaleX, data.scaleY, 1);
                    else dummy.scale.set(1, 1, 1);

                    dummy.updateMatrix();
                    mesh.setMatrixAt(index, dummy.matrix);
                }

                function resetEntityData(data, type) {
                    data.z = camera.position.z - spawnDistance - Math.random() * 30;
                    
                    if (type === 'tree' || type === 'bush') {
                        const spread = 800; 
                        data.x = camera.position.x + (Math.random() - 0.5) * spread;
                    } else if (type === 'flower') {
                        data.active = false;
                        data.z = -999; 
                        return; 
                    }
                }

                const updateControl = (xRatio) => { mouseXNormal = xRatio * 2 - 1; };
                window.addEventListener('mousemove', e => updateControl(e.clientX / window.innerWidth));
                const handleTouch = (e) => { if (e.touches.length > 0) updateControl(e.touches[0].clientX / window.innerWidth); };
                window.addEventListener('touchmove', handleTouch, {passive: true});
                window.addEventListener('touchstart', handleTouch, {passive: true});
                window.addEventListener('touchend', () => mouseXNormal = 0);
                window.addEventListener('keydown', e => { if (['ArrowLeft','a','A'].includes(e.key)) mouseXNormal = -1.0; else if (['ArrowRight','d','D'].includes(e.key)) mouseXNormal = 1.0; });
                window.addEventListener('keyup', e => { if (['ArrowLeft','a','A','ArrowRight','d','D'].includes(e.key)) mouseXNormal = 0; });
                window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

                function animate() {
                    requestAnimationFrame(animate);
                    if (isGameOver) { renderer.render(scene, camera); return; }

                    const now = performance.now();
                    const secondsElapsed = (now - startTime) / 1000;
                    
                    const currentLevel = Math.floor(secondsElapsed / 20); // å‡çº§æ›´å¿«ä¸€ç‚¹
                    if (currentLevel > lastLevel) { lastLevel = currentLevel; sysLog(`é€Ÿåº¦æå‡! Level ${currentLevel}`, 'warn'); }
                    const targetSpeed = baseSpeed + (currentLevel * 0.1);
                    speed += (targetSpeed - speed) * 0.01;
                    
                    distanceRun += speed; 
                    time += 0.05;

                    // å¥–åŠ±ç”Ÿæˆ
                    if (now - lastFlowerSpawnTime > flowerSpawnInterval) {
                        spawnBonus();
                        lastFlowerSpawnTime = now;
                        flowerSpawnInterval = 1500 + Math.random() * 2000; 
                    }
                    
                    // æ»‘é›ªç‰©ç†æ‰‹æ„Ÿ
                    if (Math.abs(mouseXNormal) > 0.1) {
                        playerVelocityX += mouseXNormal * 0.06; 
                    } else {
                        playerVelocityX *= 0.92; // é˜»åŠ›ç¨å¤§ï¼Œæ›´å®¹æ˜“åœä¸‹æ¥
                    }
                    playerVelocityX = Math.max(-1.2, Math.min(1.2, playerVelocityX)); 
                    camera.position.x += playerVelocityX;

                    // æ‘„åƒæœºé«˜åº¦è·Ÿéšåœ°å½¢
                    const cameraWorldZ = camera.position.z - distanceRun;
                    const currentGroundY = getElevation(camera.position.x, cameraWorldZ);
                    const targetCameraY = currentGroundY + playerHeight;
                    camera.position.y += (targetCameraY - camera.position.y) * 0.2; // æ›´ç´§å¯†çš„è·Ÿéš

                    // åœ°é¢ç§»åŠ¨é€»è¾‘
                    ground.position.x = camera.position.x;
                    ground.position.z = camera.position.z - 20;

                    const posAttribute = groundGeo.attributes.position;
                    const vertex = new THREE.Vector3();
                    for (let i = 0; i < posAttribute.count; i++) {
                        vertex.fromBufferAttribute(posAttribute, i);
                        const localZ = -vertex.y; 
                        const renderZ = ground.position.z + localZ;
                        const worldZ = renderZ - distanceRun; 
                        const worldX = ground.position.x + vertex.x;
                        const elevation = getElevation(worldX, worldZ);
                        posAttribute.setZ(i, elevation);
                    }
                    posAttribute.needsUpdate = true;
                    groundGeo.computeVertexNormals();
                    
                    score++; 
                    const distanceScore = Math.floor(score / 10);
                    finalScore = distanceScore + bonusScore;
                    const scoreEl = document.getElementById('score');
                    if (scoreEl) scoreEl.innerText = finalScore;

                    // --- æ›´æ–°æ ‘æœ¨ (éšœç¢ç‰©) ---
                    for (let i = 0; i < treeCount; i++) {
                        const data = treesData[i];
                        data.z += speed; 
                        const worldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, worldZ) // è°ƒæ•´ä¸­å¿ƒç‚¹  å¤‡é€‰æŠ¬é«˜:"+ data.scaleY/2;" 

                        const distZ = data.z - camera.position.z;
                        if (distZ > -0.5 && distZ < 0.5) {
                            const distX = Math.abs(data.x - camera.position.x);
                            // ç¢°æ’æ£€æµ‹
                            if (distX < 0.8) { handleGameOver(); break; }
                        }
                        
                        const isBehind = data.z > camera.position.z + 5;
                        if (isBehind) resetEntityData(data, 'tree');
                        updateMeshMatrix(treeMesh, treesData, i);
                    }
                    treeMesh.instanceMatrix.needsUpdate = true;

                    // --- æ›´æ–°å²©çŸ³ (éšœç¢ç‰©) ---
                    for (let i = 0; i < bushCount; i++) {
                        const data = bushesData[i];
                        data.z += speed; 
                        const worldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, worldZ) + 0.5;

                        const distZ = data.z - camera.position.z;
                        if (distZ > -0.5 && distZ < 0.5) {
                            const distX = Math.abs(data.x - camera.position.x);
                            if (distX < 0.8) { handleGameOver(); break; }
                        }

                        const isBehind = data.z > camera.position.z + 5;
                        if (isBehind) resetEntityData(data, 'bush');
                        updateMeshMatrix(bushMesh, bushesData, i);
                    }
                    bushMesh.instanceMatrix.needsUpdate = true;

                    // --- æ›´æ–°é‡‘å¸ (å¥–åŠ±) ---
                    for (let i = 0; i < flowerPoolSize; i++) {
                        const data = flowersData[i];
                        if (!data.active) {
                            dummy.position.set(0, -10000, 0); 
                            flowerMesh.setMatrixAt(i, dummy.matrix);
                            continue;
                        }

                        data.z += speed; 
                        const worldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, worldZ) + 1.0; 

                        // ç¢°æ’æ£€æµ‹ (æ”¶é›†)
                        const distZ = data.z - camera.position.z;
                        if (distZ > -1.0 && distZ < 0.5) {
                            const distX = Math.abs(data.x - camera.position.x);
                            if (distX < 1.5) { 
                                data.active = false;
                                bonusScore += 20; // é‡‘å¸åˆ†å€¼æ›´é«˜
                                showFloatingText("+20m â„ï¸");
                                sysLog("è·å¾—é‡‘å¸å¥–åŠ±ï¼");
                            }
                        }

                        const isBehind = data.z > camera.position.z + 5;
                        if (isBehind) resetEntityData(data, 'flower'); 
                        updateMeshMatrix(flowerMesh, flowersData, i);
                    }
                    flowerMesh.instanceMatrix.needsUpdate = true;

                    // â„ï¸ é›ªèŠ±ä¸‹è½é€»è¾‘ (ä¿®æ­£ç‰ˆ)
                    const positions = particleGeo.attributes.position.array;
                    for(let i=0; i<particleCount*3; i+=3) {
                        // 1. å·¦å³è½»å¾®é£˜åŠ¨ (æ¨¡æ‹Ÿé£)
                        positions[i] += Math.sin(time * 3 + positions[i+1]) * 0.02;
                        
                        // 2. ä¸‹è½ Y
                        positions[i+1] -= 0.15;

                        // 3. ç›¸å¯¹è¿åŠ¨ Z (ç²’å­å‘åé£ = ç©å®¶å‘å‰å†²)
                        // æ³¨æ„ï¼šè¿™é‡Œç²’å­æ˜¯ç›¸å¯¹ç›¸æœºçš„ï¼Œæ‰€ä»¥ Z å¢åŠ æ„å‘³ç€ç²’å­å¾€ç›¸æœºåé¢è·‘
                        positions[i+2] += speed * 0.8; 

                        // 4. å¾ªç¯é‡ç½®æœºåˆ¶
                        // å¦‚æœæ‰åˆ°åœ°ä¸‹(y<-5) æˆ–è€… è·‘åˆ°ç›¸æœºåé¢å¤ªè¿œ(z>10)
                        if(positions[i+1] < -5 || positions[i+2] > 10) {
                            // é‡ç½®åˆ°ä¸Šæ–¹å’Œå‰æ–¹
                            positions[i+1] = 20 + Math.random() * 10; // é«˜ç©º
                            positions[i+2] = -40 - Math.random() * 20; // è¿œå¤„
                            // å…³é”®ï¼šåœ¨å®½èŒƒå›´å†…éšæœºé‡ç½® Xï¼Œç¡®ä¿ä¸ä¼šèšé›†
                            positions[i] = (Math.random() - 0.5) * 150; 
                        }
                    }
                    
                    // ç²’å­ç³»ç»Ÿå§‹ç»ˆè·Ÿéšç›¸æœºä½ç½® (å½¢æˆä¸€ä¸ªè·Ÿéšç©å®¶çš„æš´é£é›ªç›’å­)
                    particleSystem.position.x = camera.position.x;
                    particleSystem.position.z = camera.position.z;
                    particleGeo.attributes.position.needsUpdate = true;

                    renderer.render(scene, camera);
                }

                function handleGameOver() {
                    sysLog(`ç¿»è½¦äº†! æœ€ç»ˆè·ç¦»: ${finalScore}`);
                    isGameOver = true;
                    // ç®€å•çš„éœ‡åŠ¨æ•ˆæœ/é¢œè‰²å˜çº¢æç¤º
                    scene.background = new THREE.Color(0xffcccc);
                    scene.fog = new THREE.Fog(0xffcccc, 5, 50);
                    onGameOverUI(finalScore);
                }

                animate();
                sysLog("æ»‘é›ªåœºå·²å¼€æ”¾!", 'success');
            } catch (e) { sysLog(`Init Crash: ${e.message}`, 'error'); }
        }
    </script>
</body>
</html>
