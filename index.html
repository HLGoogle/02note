<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dark Forest - Silhouette</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Helvetica Neue', Arial, sans-serif; }
        
        /* UI å±‚ */
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: #888; font-weight: bold; z-index: 10;
            font-size: 18px; letter-spacing: 1px; pointer-events: none;
            mix-blend-mode: difference;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: #666; font-size: 14px;
            pointer-events: none; opacity: 0.8; z-index: 10;
        }

        /* æµ®åŠ¨æ–‡å­—åŠ¨ç”»å®¹å™¨ */
        #floating-text-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden; z-index: 15;
        }
        
        .floating-score {
            position: absolute;
            color: #ff3333;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 5px #ff0000;
            animation: floatUp 1.5s ease-out forwards;
            left: 50%; /* é»˜è®¤å±…ä¸­ï¼ŒJSä¼šå¾®è°ƒ */
            transform: translateX(-50%);
        }

        @keyframes floatUp {
            0% { opacity: 1; top: 40%; transform: translateX(-50%) scale(0.5); }
            20% { opacity: 1; transform: translateX(-50%) scale(1.2); }
            100% { opacity: 0; top: 20%; transform: translateX(-50%) scale(1.0); }
        }

        /* è°ƒè¯•æ—¥å¿—çª—å£ (å³ä¸‹è§’) */
        #debug-console {
            position: fixed;
            bottom: 10px; right: 10px; width: 320px; height: 150px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00; font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px; padding: 10px; overflow-y: auto;
            z-index: 10001; border: 1px solid #333; pointer-events: auto;
            text-align: left; line-height: 1.4; opacity: 0.7;
        }
        #debug-console::-webkit-scrollbar { width: 5px; }
        #debug-console::-webkit-scrollbar-thumb { background: #333; }

        /* åŠ è½½ç•Œé¢ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #080808; color: #666;
            display: flex; justify-content: center; align-items: center;
            z-index: 1000; flex-direction: column;
            transition: opacity 0.8s ease-out;
        }
        .loader-bar {
            width: 200px; height: 4px; background: #222;
            border-radius: 2px; overflow: hidden; margin-top: 15px; position: relative;
        }
        .loader-progress {
            position: absolute; left: 0; top: 0; height: 100%; width: 50%;
            background: #d32f2f; animation: slide 1.5s infinite ease-in-out;
            transition: width 0.3s, background 0.3s;
        }
        @keyframes slide {
            0% { left: -50%; width: 30%; }
            50% { left: 20%; width: 80%; }
            100% { left: 100%; width: 10%; }
        }
        #loader-text { font-size: 12px; letter-spacing: 2px; text-transform: uppercase; }

        /* æ¸¸æˆç»“æŸå¼¹çª— - å‡çº§ç‰ˆ */
        #game-over-modal {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95); 
            color: #ccc; padding: 30px;
            text-align: center; border: 1px solid #333; border-radius: 8px;
            z-index: 20; width: 320px; 
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
            max-height: 80vh; /* é˜²æ­¢å¤ªé«˜è¶…å‡ºå±å¹• */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        #game-over-modal h1 { margin: 0 0 10px 0; color: #d32f2f; font-size: 32px; letter-spacing: 2px; }
        
        /* åå­—è¾“å…¥åŒºåŸŸ */
        #name-input-section {
            display: none; /* é»˜è®¤éšè—ï¼Œæœ‰èµ„æ ¼æ‰æ˜¾ç¤º */
            margin: 15px 0;
            animation: fadeIn 0.5s;
        }
        
        input#player-name {
            background: #222; border: 1px solid #444; color: #fff;
            padding: 8px; font-size: 16px; width: 60%; text-align: center;
            border-radius: 4px; outline: none;
        }
        input#player-name:focus { border-color: #d32f2f; }

        button#submit-score-btn {
            background: #d32f2f; color: #fff; border: none; padding: 8px 15px;
            font-size: 14px; border-radius: 4px; cursor: pointer; margin-left: 5px;
        }

        /* çŠ¶æ€æç¤ºä¿¡æ¯ */
        #rank-status-msg {
            font-size: 12px; color: #888; margin-top: 5px; min-height: 18px;
        }

        /* æ’è¡Œæ¦œåˆ—è¡¨åŒºåŸŸ */
        #leaderboard-section {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #leaderboard-title {
            font-size: 14px; color: #aaa; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;
        }

        #leaderboard-list {
            list-style: none; padding: 0; margin: 0;
            overflow-y: auto;
            max-height: 200px; /* é™åˆ¶é«˜åº¦ï¼Œå†…éƒ¨æ»šåŠ¨ */
            font-size: 13px;
            text-align: left;
            border: 1px solid #222;
            background: #000;
        }
        
        #leaderboard-list::-webkit-scrollbar { width: 4px; }
        #leaderboard-list::-webkit-scrollbar-thumb { background: #333; }

        #leaderboard-list li {
            padding: 6px 10px;
            border-bottom: 1px solid #111;
            display: flex; justify-content: space-between;
        }
        #leaderboard-list li:nth-child(odd) { background: #050505; }
        #leaderboard-list li.highlight { color: #d32f2f; font-weight: bold; background: #1a0505; }
        
        .rank-num { width: 25px; color: #555; display: inline-block; }
        .rank-name { flex-grow: 1; padding-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .rank-score { color: #ccc; }

        .btn-group { display: flex; flex-direction: column; gap: 12px; margin-top: 20px; }
        button.action-btn { 
            border: none; padding: 12px; font-size: 14px; cursor: pointer; border-radius: 2px; color: #fff; transition: 0.2s; 
        }
        
        #restart-btn { background: #8b0000; }
        #restart-btn:hover { background: #a50000; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="loader">
        <div id="loader-text">INITIALIZING...</div>
        <div class="loader-bar"><div class="loader-progress"></div></div>
    </div>

    <div id="ui">è·ç¦»: <span id="score">0</span> ç±³</div>
    <div id="guide">ğŸ–±ï¸/âŒ¨ï¸/ğŸ‘† å·¦å³é—ªé¿</div>
    <div id="floating-text-container"></div>

    <div id="debug-console">
        <div>> System Booting...</div>
    </div>

    <div id="game-over-modal" style="display: none;">
        <h1>ç†„ç­</h1>
        <p>å­˜æ´»è·ç¦»: <span id="final-score" style="color: #fff; font-weight: bold;">0</span> ç±³</p>
        
        <!-- åå­—è¾“å…¥åŒºåŸŸ (ä»…å½“å‰50åæ˜¾ç¤º) -->
        <div id="name-input-section">
            <div style="color: #d32f2f; font-size: 14px; margin-bottom: 5px;">ğŸ”¥ æ–°çºªå½•ï¼æ¦œä¸Šæœ‰å ğŸ”¥</div>
            <div style="display: flex; justify-content: center;">
                <input type="text" id="player-name" placeholder="è¾“å…¥ä½ çš„åå­—" maxlength="10">
                <button id="submit-score-btn" onclick="submitScore()">ç™»è®°</button>
            </div>
        </div>

        <!-- çŠ¶æ€/æç¤ºä¿¡æ¯ -->
        <div id="rank-status-msg">æ­£åœ¨è¿æ¥æ•°æ®åº“...</div>

        <!-- æ’è¡Œæ¦œå±•ç¤º -->
        <div id="leaderboard-section">
            <div id="leaderboard-title">TOP 50 å¹¸å­˜è€…</div>
            <ul id="leaderboard-list">
                <!-- JS åŠ¨æ€ç”Ÿæˆ -->
                <li style="text-align: center; color: #666; padding: 20px;">åŠ è½½ä¸­...</li>
            </ul>
        </div>

        <div class="btn-group">
            <button id="restart-btn" class="action-btn" onclick="location.reload()">é‡æ–°ç‚¹ç‡ƒç«æŠŠ</button>
        </div>
    </div>

    <script>
        // ==========================================
        // ğŸ”§ é…ç½®åŒºåŸŸ
        // ==========================================
        
        // è¯·åœ¨æ­¤å¤„å¡«å…¥ä½ çš„ Cloudflare Worker åœ°å€
        // ä¾‹å¦‚: const CLOUDFLARE_WORKER_URL = "https://dark-forest-rank.your-name.workers.dev";
        const CLOUDFLARE_WORKER_URL = ""; 

        // ==========================================
        
        // æ—¥å¿—ç³»ç»Ÿ
        function sysLog(msg, type='info') {
            const consoleEl = document.getElementById('debug-console');
            if(!consoleEl) return;
            const time = new Date().toLocaleTimeString('en-US', {hour12: false, hour: "numeric", minute: "numeric", second: "numeric"});
            const div = document.createElement('div');
            if(type === 'error') { div.style.color = '#ff3333'; div.innerHTML = `[${time}] âŒ ${msg}`; console.error(msg); } 
            else if (type === 'warn') { div.style.color = '#ffff33'; div.innerHTML = `[${time}] âš ï¸ ${msg}`; } 
            else if (type === 'success') { div.style.color = '#33ff33'; div.innerHTML = `[${time}] âœ… ${msg}`; }
            else { div.innerHTML = `[${time}] > ${msg}`; }
            consoleEl.appendChild(div);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ
        function showFloatingText(text) {
            const container = document.getElementById('floating-text-container');
            const el = document.createElement('div');
            el.className = 'floating-score';
            el.innerText = text;
            container.appendChild(el);
            setTimeout(() => { if(el.parentNode) el.parentNode.removeChild(el); }, 1500);
        }

        // --- æ’è¡Œæ¦œé€»è¾‘ ---

        // æ¨¡æ‹Ÿæ•°æ® (å½“æ²¡æœ‰é…ç½® Cloudflare URL æ—¶ä½¿ç”¨)
        const MOCK_DATA_KEY = 'dark_forest_mock_leaderboard';
        function getMockLeaderboard() {
            let data = localStorage.getItem(MOCK_DATA_KEY);
            if (!data) {
                // åˆå§‹åŒ–ä¸€äº›å‡æ•°æ®
                const initial = [
                    { name: "Shadow", score: 500 },
                    { name: "Light", score: 320 },
                    { name: "Runner", score: 150 },
                    { name: "Wolf", score: 80 },
                    { name: "Echo", score: 40 }
                ];
                localStorage.setItem(MOCK_DATA_KEY, JSON.stringify(initial));
                return initial;
            }
            return JSON.parse(data);
        }

        // è·å–æ’è¡Œæ¦œ
        async function fetchLeaderboard() {
           const apiUrl = CLOUDFLARE_WORKER_URL || ""; // ä¸ºç©ºåˆ™ä½¿ç”¨ç›¸å¯¹è·¯å¾„
        try {
            // å¦‚æœapiUrlä¸ºç©ºï¼Œfetch("/rankings") ä¼šè‡ªåŠ¨è¯·æ±‚å½“å‰åŸŸå
            const response = await fetch(`${apiUrl}/rankings`);
            if (!response.ok) throw new Error("API Error");
            return await response.json();
        } catch (e) {
            sysLog(`Fetch Rank Failed: ${e.message}`, 'error');
            return getMockLeaderboard(); 
        }
        }

       // æäº¤åˆ†æ•°çš„é€»è¾‘ä¿®å¤
    async function sendScoreToDB(name, score) {
        const apiUrl = CLOUDFLARE_WORKER_URL || "";
        try {
            const response = await fetch(`${apiUrl}/submit`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, score })
            });
            return response.ok;
        } catch (e) {
            sysLog(`Submit Failed: ${e.message}`, 'error');
            return false;
        }
    }
        // å…¨å±€å˜é‡ä¿å­˜å½“å‰æ¸¸æˆç»“æŸæ—¶çš„åˆ†æ•°å’Œæ’åæ•°æ®
        let currentFinalScore = 0;
        let cachedLeaderboard = [];

        // æ¸¸æˆç»“æŸå¤„ç† (UIéƒ¨åˆ†)
        async function onGameOverUI(score) {
            currentFinalScore = score;
            const modal = document.getElementById('game-over-modal');
            const scoreText = document.getElementById('final-score');
            const inputSection = document.getElementById('name-input-section');
            const msgEl = document.getElementById('rank-status-msg');
            const listEl = document.getElementById('leaderboard-list');

            scoreText.innerText = score;
            modal.style.display = 'flex';
            inputSection.style.display = 'none'; // å…ˆéšè—è¾“å…¥æ¡†
            msgEl.innerText = "æ­£åœ¨è·å–æ’åæ•°æ®...";
            listEl.innerHTML = '<li style="text-align:center; padding:20px; color:#666;">åŠ è½½ä¸­...</li>';

            // è·å–æ•°æ®
            cachedLeaderboard = await fetchLeaderboard();
            
            // æ¸²æŸ“åˆ—è¡¨
            renderLeaderboard(cachedLeaderboard);

            // æ£€æŸ¥æ˜¯å¦æœ‰èµ„æ ¼ä¸Šæ¦œ (å‰50å æˆ– æ¦œå•ä¸æ»¡50)
            const maxListSize = 50;
            const minScoreOnBoard = cachedLeaderboard.length < maxListSize ? 0 : cachedLeaderboard[cachedLeaderboard.length - 1].score;

            if (score > minScoreOnBoard || cachedLeaderboard.length < maxListSize) {
                // æœ‰èµ„æ ¼
                inputSection.style.display = 'block';
                msgEl.innerText = "è¯·è¾“å…¥åå­—ä»¥ç™»è®°æˆç»©";
                msgEl.style.color = "#d32f2f";
            } else {
                // æ²¡èµ„æ ¼
                inputSection.style.display = 'none';
                msgEl.innerText = "è·ç¦»ä¸Šæ¦œè¿˜å·®ä¸€ç‚¹ç‚¹ï¼Œä¸‹æ¬¡åŠªåŠ›ï¼";
                msgEl.style.color = "#888";
            }
        }

        // æ¸²æŸ“åˆ—è¡¨ DOM
        function renderLeaderboard(data) {
            const listEl = document.getElementById('leaderboard-list');
            listEl.innerHTML = '';
            
            if (data.length === 0) {
                listEl.innerHTML = '<li style="text-align:center; padding:20px; color:#444;">æš‚æ— æ•°æ®ï¼Œå¿«æ¥æŠ¢ç¬¬ä¸€ï¼</li>';
                return;
            }

            data.forEach((item, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="rank-num">${index + 1}.</span>
                    <span class="rank-name">${escapeHtml(item.name)}</span>
                    <span class="rank-score">${item.score}m</span>
                `;
                listEl.appendChild(li);
            });
        }

        // ç‚¹å‡»æäº¤æŒ‰é’®
        async function submitScore() {
            const input = document.getElementById('player-name');
            const btn = document.getElementById('submit-score-btn');
            const name = input.value.trim();
            
            if (!name) {
                alert("åå­—ä¸èƒ½ä¸ºç©º");
                return;
            }

            btn.disabled = true;
            btn.innerText = "æäº¤ä¸­...";

            const success = await sendScoreToDB(name, currentFinalScore);
            
            if (success) {
                document.getElementById('name-input-section').style.display = 'none';
                document.getElementById('rank-status-msg').innerText = "ç™»è®°æˆåŠŸï¼";
                document.getElementById('rank-status-msg').style.color = "#33ff33";
                // åˆ·æ–°åˆ—è¡¨
                cachedLeaderboard = await fetchLeaderboard();
                renderLeaderboard(cachedLeaderboard);
            } else {
                btn.disabled = false;
                btn.innerText = "é‡è¯•";
                alert("æäº¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ");
            }
        }

        function escapeHtml(text) {
            if (!text) return "Unknown";
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }


        // CDN åˆ—è¡¨
        const CDN_LIST = [
            "https://lib.baomitu.com/three.js/r128/three.min.js",
            "https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js",
            "https://cdn.staticfile.org/three.js/r128/three.min.js",
            "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
        ];

        let currentCdnIndex = 0;

        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = () => resolve();
                script.onerror = () => reject();
                document.head.appendChild(script);
            });
        }

        async function tryLoadEngine() {
            if (currentCdnIndex >= CDN_LIST.length) {
                sysLog("ALL CONNECTIONS FAILED.", 'error');
                document.getElementById('loader-text').innerText = "FATAL ERROR: NO NETWORK";
                document.querySelector('.loader-progress').style.background = "#ff0000";
                return;
            }

            const url = CDN_LIST[currentCdnIndex];
            sysLog(`Attempting connection to Node ${currentCdnIndex + 1}...`);
            document.getElementById('loader-text').innerText = `CONNECTING TO NODE ${currentCdnIndex + 1}...`;

            try {
                const loadPromise = loadScript(url);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error("Timeout")), 3000) 
                );

                await Promise.race([loadPromise, timeoutPromise]);
                
                sysLog("Engine Loaded Successfully!", 'success');
                document.getElementById('loader-text').innerText = "LOADING ASSETS...";
                
                setTimeout(initGame, 100);

            } catch (error) {
                sysLog(`Node ${currentCdnIndex + 1} Failed/Timeout. Switching...`, 'warn');
                currentCdnIndex++;
                tryLoadEngine(); 
            }
        }

        tryLoadEngine();

        // --- ğŸ¨ ç¨‹åºåŒ–çº¹ç†ç”Ÿæˆå™¨ ---
        function createTreeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#ffffff';
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(220, 1024); ctx.lineTo(292, 1024);
            ctx.bezierCurveTo(280, 600, 270, 300, 256, 50); 
            ctx.bezierCurveTo(242, 300, 232, 600, 220, 1024);
            ctx.fill();
            const drawBranch = (x, y, len, angle, width) => {
                if(width < 2 || len < 20) return;
                const endX = x + len * Math.sin(angle);
                const endY = y - len * Math.cos(angle);
                ctx.lineWidth = width; ctx.beginPath(); ctx.moveTo(x, y);
                const midX = (x + endX) / 2 + (Math.random() - 0.5) * 20;
                const midY = (y + endY) / 2;
                ctx.quadraticCurveTo(midX, midY, endX, endY);
                ctx.stroke();
                const subCount = 2;
                for(let i=0; i<subCount; i++) {
                    const dir = (Math.random() > 0.5 ? 1 : -1);
                    const newAngle = angle + dir * (0.3 + Math.random() * 0.4);
                    const newLen = len * (0.6 + Math.random() * 0.2);
                    drawBranch(endX, endY, newLen, newAngle, width * 0.6);
                }
            };
            drawBranch(256, 700, 180, -0.6, 25); drawBranch(256, 550, 160, 0.7, 20);
            drawBranch(256, 350, 120, -0.5, 15); drawBranch(256, 200, 80, 0.3, 10);
            return new THREE.CanvasTexture(canvas);
        }

        function createBushTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            const count = 15;
            for(let i=0; i<count; i++) {
                const r = 30 + Math.random() * 40;
                const x = 50 + Math.random() * 156;
                const y = 180 + Math.random() * 60; 
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        // æ–°å¢ï¼šèŠ±æœµçº¹ç† (çº¢è‰²çš„å½¼å²¸èŠ±é£æ ¼)
        function createFlowerTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,256,256);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(128, 256);
            ctx.quadraticCurveTo(128, 150, 128, 100);
            ctx.stroke();
            ctx.translate(128, 80);
            ctx.fillStyle = '#ffffff';
            for(let i=0; i<12; i++) {
                ctx.rotate(Math.PI * 2 / 12);
                ctx.beginPath();
                ctx.ellipse(0, 40, 6, 40, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // --- â›°ï¸ åœ°å½¢ç³»ç»Ÿ (ä¸–ç•Œåæ ‡ç³») ---
        function getElevation(x, z) {
            const h1 = Math.sin(x * 0.05) * Math.cos(z * 0.03) * 3.5;
            const h2 = Math.cos(x * 0.12 + 1.5) * Math.sin(z * 0.1 + 0.5) * 1.2;
            return -4.0 + h1 + h2; 
        }

        // --- æ¸¸æˆä¸»é€»è¾‘ ---
        function initGame() {
            try {
                let baseSpeed = 0.45; let speed = baseSpeed;
                let score = 0; // åŸºç¡€è®¡æ—¶åˆ†æ•°
                let bonusScore = 0; // å¥–åŠ±åˆ†æ•°
                let playerVelocityX = 0; let mouseXNormal = 0;
                let isGameOver = false; let time = 0; let finalScore = 0;
                let startTime = performance.now(); let lastLevel = 0;
                
                let distanceRun = 0;
                const playerHeight = 1.8; 

                // --- èŠ±æœµç”Ÿæˆæ§åˆ¶ ---
                let lastFlowerSpawnTime = performance.now();
                // ç¬¬ä¸€æ¬¡ç”Ÿæˆå¯ä»¥å¿«ä¸€ç‚¹ï¼Œæ¯”å¦‚2ç§’å
                let flowerSpawnInterval = 2000; 

                sysLog("Initializing Scene...");
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050505);
                scene.fog = new THREE.Fog(0x000000, 10, 80); 

                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
                camera.position.set(0, playerHeight, 5);

                const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 800);

                const torch = new THREE.SpotLight(0xffddaa, 2.0);
                torch.distance = 100; torch.angle = Math.PI / 4;
                torch.penumbra = 0.5; torch.decay = 1.5; torch.castShadow = true;
                torch.position.set(0, 0, 0); torch.target.position.set(0, 0, -20);
                torch.shadow.bias = -0.0005; 
                torch.shadow.mapSize.width = 1024; torch.shadow.mapSize.height = 1024;
                camera.add(torch); camera.add(torch.target); scene.add(camera);
                
                const ambient = new THREE.AmbientLight(0x404040); scene.add(ambient);

                // --- åœ°é¢ ---
                const groundMat = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, roughness: 0.95, metalness: 0.05 
                });
                const groundGeo = new THREE.PlaneGeometry(200, 200, 60, 60);
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2; 
                ground.receiveShadow = true; 
                scene.add(ground);

                sysLog("Generating textures...");
                const treeTexture = createTreeTexture();
                const bushTexture = createBushTexture();
                const flowerTexture = createFlowerTexture();

                // --- å®ä½“ç³»ç»Ÿ ---
                const treeCount = 500; const bushCount = 400; 
                const flowerPoolSize = 10; 
                const spawnDistance = 120; const lateralCullDist = 550; 
                
                // æ ‘
                const treeGeo = new THREE.PlaneGeometry(1, 1); treeGeo.translate(0, 0.5, 0); 
                const treeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a, roughness: 1.0, map: treeTexture, alphaTest: 0.4, side: THREE.DoubleSide, transparent: false 
                });
                treeMat.customDepthMaterial = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking, map: treeTexture, alphaTest: 0.4 });
                const treeMesh = new THREE.InstancedMesh(treeGeo, treeMat, treeCount);
                treeMesh.castShadow = false; treeMesh.receiveShadow = true;
                treeMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                scene.add(treeMesh);

                // çŒæœ¨
                const bushGeo = new THREE.PlaneGeometry(1, 1); bushGeo.translate(0, 0.5, 0);
                const bushMat = new THREE.MeshStandardMaterial({ 
                    color: 0x151515, roughness: 1.0, map: bushTexture, alphaTest: 0.3, side: THREE.DoubleSide 
                });
                bushMat.customDepthMaterial = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking, map: bushTexture, alphaTest: 0.3 });
                const bushMesh = new THREE.InstancedMesh(bushGeo, bushMat, bushCount);
                bushMesh.castShadow = false; bushMesh.receiveShadow = true;
                bushMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                scene.add(bushMesh);

                // ğŸŒº èŠ±æœµ (å¥–åŠ±ç‰©å“)
                const flowerGeo = new THREE.PlaneGeometry(1, 1); flowerGeo.translate(0, 0.5, 0);
                const flowerMat = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff3333,
                    emissiveIntensity: 0.8,
                    map: flowerTexture,
                    alphaTest: 0.5,
                    side: THREE.DoubleSide,
                    transparent: true 
                });
                const flowerMesh = new THREE.InstancedMesh(flowerGeo, flowerMat, flowerPoolSize);
                flowerMesh.castShadow = false; flowerMesh.receiveShadow = false;
                flowerMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                scene.add(flowerMesh);

                const treesData = []; const bushesData = []; const flowersData = [];
                const dummy = new THREE.Object3D(); 

                for (let i = 0; i < treeCount; i++) treesData.push(createEntityData('tree'));
                for (let i = 0; i < bushCount; i++) bushesData.push(createEntityData('bush'));
                for (let i = 0; i < flowerPoolSize; i++) flowersData.push(createEntityData('flower'));

                function createEntityData(type) {
                    const spread = 1000;
                    const z = -Math.random() * spawnDistance;
                    let x = (Math.random() - 0.5) * spread;
                    
                    if (type === 'tree') {
                        const isTall = Math.random() > 0.6;
                        const scaleY = isTall ? (30 + Math.random() * 40) : (16 + Math.random() * 16);
                        const scaleX = isTall ? (5.0 + Math.random() * 3.0) : (7.0 + Math.random() * 4.0);
                        return { x, z, scaleX, scaleY };
                    } else if (type === 'bush') {
                        const scaleY = 2.0 + Math.random() * 3.0;
                        const scaleX = 4.0 + Math.random() * 5.0;
                        return { x, z, scaleX, scaleY };
                    } else if (type === 'flower') {
                        return { x: 0, z: -999, scaleX: 1.5, scaleY: 1.5, active: false }; 
                    }
                }

                function spawnFlower() {
                    const flower = flowersData.find(f => !f.active);
                    if (flower) {
                        flower.active = true;
                        flower.z = camera.position.z - spawnDistance;
                        flower.x = camera.position.x + (Math.random() - 0.5) * 40;
                        sysLog("Bonus Flower Spawned!", 'info');
                    }
                }

                // ç²’å­
                const particleCount = 600;
                const particleGeo = new THREE.BufferGeometry();
                const particlePos = new Float32Array(particleCount * 3);
                for(let i=0; i<particleCount*3; i+=3) {
                    particlePos[i] = (Math.random() - 0.5) * 60;   
                    particlePos[i+1] = (Math.random() - 0.5) * 20; 
                    particlePos[i+2] = -Math.random() * 100;       
                }
                particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
                const particleMat = new THREE.PointsMaterial({ color: 0x888888, size: 0.15, transparent: true, opacity: 0.5 });
                const particleSystem = new THREE.Points(particleGeo, particleMat);
                camera.add(particleSystem); 

                function updateMeshMatrix(mesh, dataArray, index) {
                    const data = dataArray[index];
                    dummy.position.set(data.x, data.y, data.z);
                    
                    if (mesh === flowerMesh) {
                        dummy.rotation.set(0, time * 2 + index, 0);
                    } else {
                        dummy.rotation.set(0, 0, 0); 
                    }
                    
                    dummy.scale.set(data.scaleX, data.scaleY, 1);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(index, dummy.matrix);
                }

                function resetEntityData(data, type) {
                    data.z = camera.position.z - spawnDistance - Math.random() * 30;
                    
                    if (type === 'tree' || type === 'bush') {
                        const spread = 1000; 
                        data.x = camera.position.x + (Math.random() - 0.5) * spread;
                    } else if (type === 'flower') {
                        data.active = false;
                        data.z = -999; 
                        return; 
                    }

                    if (type === 'tree') {
                        const isTall = Math.random() > 0.6;
                        data.scaleY = isTall ? (30 + Math.random() * 40) : (16 + Math.random() * 16);
                        data.scaleX = isTall ? (5.0 + Math.random() * 3.0) : (7.0 + Math.random() * 4.0);
                    } else if (type === 'bush') {
                        data.scaleY = 2.0 + Math.random() * 3.0;
                        data.scaleX = 4.0 + Math.random() * 5.0;
                    } 
                }

                const updateControl = (xRatio) => { mouseXNormal = xRatio * 2 - 1; };
                window.addEventListener('mousemove', e => updateControl(e.clientX / window.innerWidth));
                const handleTouch = (e) => { if (e.touches.length > 0) updateControl(e.touches[0].clientX / window.innerWidth); };
                window.addEventListener('touchmove', handleTouch, {passive: true});
                window.addEventListener('touchstart', handleTouch, {passive: true});
                window.addEventListener('touchend', () => mouseXNormal = 0);
                window.addEventListener('keydown', e => { if (['ArrowLeft','a','A'].includes(e.key)) mouseXNormal = -1.0; else if (['ArrowRight','d','D'].includes(e.key)) mouseXNormal = 1.0; });
                window.addEventListener('keyup', e => { if (['ArrowLeft','a','A','ArrowRight','d','D'].includes(e.key)) mouseXNormal = 0; });
                window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

                function animate() {
                    requestAnimationFrame(animate);
                    if (isGameOver) { renderer.render(scene, camera); return; }

                    const now = performance.now();
                    const secondsElapsed = (now - startTime) / 1000;
                    
                    const currentLevel = Math.floor(secondsElapsed / 30);
                    if (currentLevel > lastLevel) { lastLevel = currentLevel; sysLog(`Speed Level Up: ${currentLevel}`, 'warn'); }
                    const targetSpeed = baseSpeed + (currentLevel * 0.08);
                    speed += (targetSpeed - speed) * 0.01;
                    
                    distanceRun += speed; 
                    time += 0.05;

                    // --- èŠ±æœµç”Ÿæˆè®¡æ—¶å™¨ ---
                    if (now - lastFlowerSpawnTime > flowerSpawnInterval) {
                        spawnFlower();
                        lastFlowerSpawnTime = now;
                        flowerSpawnInterval = 3000 + Math.random() * 3000; 
                    }
                    
                    if (Math.abs(mouseXNormal) > 0.1) {
                        // [ADJUST] åŠ é€Ÿç³»æ•°
                        playerVelocityX += mouseXNormal * 0.08; 
                    } else {
                        // [ADJUST] åˆ¹è½¦æƒ¯æ€§ç³»æ•°
                        // å‡é€Ÿ/æƒ¯æ€§é˜¶æ®µ (æ•°å€¼è¶Šå°ï¼Œåˆ¹è½¦è¶Šå¿«ï¼Œå»ºè®® 0.1 ~ 0.7)
                        // åŸæ¥æ˜¯ 0.7 (æ»‘è¡Œè¾ƒè¿œ)ï¼Œæ”¹ä¸º 0.1 (åˆ¹è½¦æ›´å¿«ï¼Œå‡å°‘â€œæ‰“æ»‘â€æ„Ÿ)
                        playerVelocityX *= 0.1; 
                    }
                    playerVelocityX = Math.max(-1.0, Math.min(1.0, playerVelocityX)); 
                    camera.position.x += playerVelocityX;

                    const cameraWorldZ = camera.position.z - distanceRun;
                    const currentGroundY = getElevation(camera.position.x, cameraWorldZ);
                    const targetCameraY = currentGroundY + playerHeight + Math.sin(time * 3) * 0.05;
                    camera.position.y += (targetCameraY - camera.position.y) * 0.1;

                    ground.position.x = camera.position.x;
                    ground.position.z = camera.position.z - 20;

                    const posAttribute = groundGeo.attributes.position;
                    const vertex = new THREE.Vector3();
                    for (let i = 0; i < posAttribute.count; i++) {
                        vertex.fromBufferAttribute(posAttribute, i);
                        const localZ = -vertex.y; 
                        const renderZ = ground.position.z + localZ;
                        const worldZ = renderZ - distanceRun; 
                        const worldX = ground.position.x + vertex.x;
                        const elevation = getElevation(worldX, worldZ);
                        posAttribute.setZ(i, elevation);
                    }
                    posAttribute.needsUpdate = true;
                    groundGeo.computeVertexNormals();
                    
                    score++; 
                    const distanceScore = Math.floor(score / 10);
                    finalScore = distanceScore + bonusScore;
                    const scoreEl = document.getElementById('score');
                    if (scoreEl) scoreEl.innerText = finalScore;

                    // --- æ›´æ–°æ ‘æœ¨ ---
                    for (let i = 0; i < treeCount; i++) {
                        const data = treesData[i];
                        data.z += speed; 
                        const treeWorldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, treeWorldZ) - 0.5;

                        const distZ = data.z - camera.position.z;
                        if (distZ > -0.5 && distZ < 0.5) {
                            const distX = Math.abs(data.x - camera.position.x);
                            
                            // [ADJUST] ç¢°æ’ä½“ç§¯
                            // hitRadius = æ ‘å®½åº¦ * ç¢°æ’ç³»æ•°(0.2) + ç©å®¶ç¼“å†²(0.1)
                            // å¢å¤§ å‰é¢ä¸€ä¸ª0.1 å¯ä»¥è®©æ ‘æ›´éš¾èº²ï¼Œå‡å°åˆ™æ›´å®¹æ˜“èº²
                            const hitRadius = data.scaleX * 0.1 + 0.1; 

                            if (distX < hitRadius) { handleGameOver(); break; }
                        }
                        
                        const isBehind = data.z > camera.position.z + 5;
                        const isTooFarSideways = Math.abs(data.x - camera.position.x) > lateralCullDist;
                        if (isBehind || isTooFarSideways) resetEntityData(data, 'tree');
                        updateMeshMatrix(treeMesh, treesData, i);
                    }
                    treeMesh.instanceMatrix.needsUpdate = true;

                    // --- æ›´æ–°çŒæœ¨ ---
                    for (let i = 0; i < bushCount; i++) {
                        const data = bushesData[i];
                        data.z += speed; 
                        const bushWorldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, bushWorldZ);
                        const isBehind = data.z > camera.position.z + 5;
                        const isTooFarSideways = Math.abs(data.x - camera.position.x) > lateralCullDist;
                        if (isBehind || isTooFarSideways) resetEntityData(data, 'bush');
                        updateMeshMatrix(bushMesh, bushesData, i);
                    }
                    bushMesh.instanceMatrix.needsUpdate = true;

                    // --- æ›´æ–°èŠ±æœµ (å¥–åŠ±) ---
                    for (let i = 0; i < flowerPoolSize; i++) {
                        const data = flowersData[i];
                        
                        if (!data.active) {
                            dummy.position.set(0, -10000, 0); 
                            flowerMesh.setMatrixAt(i, dummy.matrix);
                            continue;
                        }

                        data.z += speed; 
                        const flowerWorldZ = data.z - distanceRun;
                        data.y = getElevation(data.x, flowerWorldZ) + 0.2; 

                        // ç¢°æ’æ£€æµ‹ (æ”¶é›†)
                        const distZ = data.z - camera.position.z;
                        if (distZ > -1.0 && distZ < 0.5) {
                            const distX = Math.abs(data.x - camera.position.x);
                            if (distX < 1.5) { 
                                data.active = false;
                                bonusScore += 10;
                                showFloatingText("+10m");
                                sysLog("Flower collected! +10m");
                            }
                        }

                        const isBehind = data.z > camera.position.z + 5;
                        if (isBehind) resetEntityData(data, 'flower'); 
                        updateMeshMatrix(flowerMesh, flowersData, i);
                    }
                    flowerMesh.instanceMatrix.needsUpdate = true;

                    const positions = particleGeo.attributes.position.array;
                    for(let i=0; i<particleCount*3; i+=3) {
                        positions[i+2] += speed * 3; 
                        if(positions[i+2] > 2) {
                            positions[i+2] = -80 - Math.random() * 20;
                            positions[i] = (Math.random() - 0.5) * 60; 
                            positions[i+1] = (Math.random() - 0.5) * 20; 
                        }
                    }
                    particleGeo.attributes.position.needsUpdate = true;

                    renderer.render(scene, camera);
                }

                function handleGameOver() {
                    sysLog(`Game Over! Score: ${finalScore}`);
                    isGameOver = true;
                    torch.color.setHex(0xff3333);
                    torch.intensity = 5;
                    
                    // è°ƒç”¨ UI é€»è¾‘
                    onGameOverUI(finalScore);
                }

                animate();
                sysLog("Game Loop Started!", 'success');
            } catch (e) { sysLog(`Init Crash: ${e.message}`, 'error'); }
        }
    </script>
</body>
</html>


